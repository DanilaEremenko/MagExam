#################################################################################
# ---------------------- BUBBLE -------------------------------------------------
#################################################################################
def bubble_sort(arr):
    """
    При этом подходе осуществляется перебор по списку и сравнение соседних элементов.
    Они меняются местами в том случае, если порядок неправильный.
    Так продолжается до тех пор, пока все элементы не расположатся в нужном порядке.

    Худший случай: O(n^2)
    Лучший случай: O(n)

    Память: O(1)
    """

    def swap(i, j):
        res[i], res[j] = res[j], res[i]

    res = arr.copy()
    n = len(res)
    swapped = True

    x = -1
    while swapped:
        swapped = False
        x = x + 1
        for i in range(1, n - x):
            if res[i - 1] > res[i]:
                swap(i - 1, i)
                swapped = True
    return res


#################################################################################
# ---------------------- SELECTION ----------------------------------------------
#################################################################################
def selection_sort(arr):
    """
    В этом алгоритме список (или массив) делится на две части: список с отсортированными элементами и список с элементами,
    которые только нужно сортировать.
    Сначала ищется самый маленький элемент во втором.
    Он добавляется в конце первого.
    Таким образом алгоритм постепенно формирует список от меньшего к большему.
    Так происходит до тех пор, пока не будет готовый отсортированный массив.

    Худший случай:  O(n^2)
    Лучший случай:  O(n^2)

    Память: O(1)
    """
    for i in range(len(arr)):
        minimum = i

        for j in range(i + 1, len(arr)):
            # Выбор наименьшего значения
            if arr[j] < arr[minimum]:
                minimum = j

        # Помещаем это перед отсортированным концом массива
        arr[minimum], arr[i] = arr[i], arr[minimum]

    return arr


#################################################################################
# ---------------------- INSERTION ----------------------------------------------
#################################################################################
def insertion_sort(arr):
    """
    Сортировка вставками быстрее и проще двух предыдущих. Именно так большинство людей тасует карты любой игре.
    На каждой итерации программа берет один из элементов и подыскивает для него место в уже отсортированном списке.
    Так происходит до тех пор, пока не останется ни одного неиспользованного элемента.

    Худший случай: O(n^2)
    Лучший случай: O(n)

    Память: O(1)
    """
    for i in range(len(arr)):
        cursor = arr[i]
        pos = i

        while pos > 0 and arr[pos - 1] > cursor:
            # Меняем местами число, продвигая по списку
            arr[pos] = arr[pos - 1]
            pos = pos - 1
        # Остановимся и сделаем последний обмен
        arr[pos] = cursor

    return arr


#################################################################################
# ---------------------- MERGE --------------------------------------------------
#################################################################################
def merge_sort(arr):
    """
    Сортировка слиянием — элегантный пример использования подхода «Разделяй и властвуй».

    Он состоит из двух этапов:
    -Несортированный список последовательно делится на N списков, где каждый включает один «несортированный» элемент, а N — это число элементов в оригинальном массиве.
    -Списки последовательно сливаются группами по два, создавая новые отсортированные списки до тех пор, пока не появится один финальный отсортированный список.

    Худший случай: O(n*log(n))
    Лучший случай: O(n*log(n))

    Память: O(n)
    """

    def merge(left, right, merged):
        left_cursor, right_cursor = 0, 0
        while left_cursor < len(left) and right_cursor < len(right):

            # Сортируем каждый и помещаем в результат
            if left[left_cursor] <= right[right_cursor]:
                merged[left_cursor + right_cursor] = left[left_cursor]
                left_cursor += 1
            else:
                merged[left_cursor + right_cursor] = right[right_cursor]
                right_cursor += 1

        for left_cursor in range(left_cursor, len(left)):
            merged[left_cursor + right_cursor] = left[left_cursor]

        for right_cursor in range(right_cursor, len(right)):
            merged[left_cursor + right_cursor] = right[right_cursor]

        return merged

    # ---------------- main part ------------------------------------
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    # Выполняем merge_sort рекурсивно с двух сторон
    left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:])

    # Объединяем стороны вместе
    return merge(left, right, arr.copy())


#################################################################################
# ---------------------- MERGE --------------------------------------------------
#################################################################################
def quick_sort(arr, begin=0, end=None):
    """
    Как и сортировка слиянием, быстрая сортировка использует подход «Разделяй и властвуй».
    Алгоритм чуть сложнее, но в стандартных реализациях он работает быстрее сортировки слиянием, а его сложность в худшем случае редко достигает O(n^2).

    Он состоит из трех этапов:
    -Выбирается один опорный элемент.
    -Все элементы меньше опорного перемешаются слева от него, остальные — направо. Это называется операцией разбиения.
    -Рекурсивно повторяются 2 предыдущих шага к каждому новому списку, где новые опорные элементы будут меньше и больше оригинального соответственно.

    Худший случай: O(n^2)
    Лучший случай: O(n*log(n))

    Память: O(log(n))
    """

    def partition(res, begin, end):
        pivot_idx = begin
        for i in range(begin + 1, end + 1):
            if res[i] <= res[begin]:
                pivot_idx += 1
                res[i], res[pivot_idx] = res[pivot_idx], res[i]
        res[pivot_idx], res[begin] = res[begin], res[pivot_idx]
        return pivot_idx

    def quick_sort_recursion(res, begin, end):
        if begin >= end:
            return
        pivot_idx = partition(res, begin, end)
        quick_sort_recursion(res, begin, pivot_idx - 1)
        quick_sort_recursion(res, pivot_idx + 1, end)

    if end is None:
        end = len(arr) - 1

    res = arr.copy()

    quick_sort_recursion(res, begin, end)
    return res


#################################################################################
# ---------------------- PYTHON -------------------------------------------------
#################################################################################
def default_sort(arr):
    return sorted(arr)
